include:
  - project: "${CICD_CONFIGURATION_PATH}"
    ref: ht-rework
    file: "build-docker/.default-conf.yml"
    rules:
      - exists:
          paths:
            - "build-docker/.default-conf.yml"
          project: "${CICD_CONFIGURATION_PATH}"
          ref: ht-rework
  - project: "${CICD_CONFIGURATION_PATH}"
    ref: ht-rework
    file: "build-docker/.${CI_PROJECT_NAME}-conf.yml"
    rules:
      - exists:
          paths:
            - "build-docker/.${CI_PROJECT_NAME}-conf.yml"
          project: "${CICD_CONFIGURATION_PATH}"
          ref: ht-rework

# Get the required files using git
#
get-changes-from-git:
  stage: prepare
  tags:
    - $RUNNER_TAGS
  # needs:
  #
  rules:
    - if: $ENABLE_BUILD != 'yes'
      when: never
    - if: $CI_PIPELINE_SOURCE =~ /^(schedule|web|trigger)/
      variables:
        CI_COMMIT_BEFORE_SHA: ${CI_COMMIT_SHA}
    - when : always
  image: ruby:2.6
  needs:
    - get-files-from-git
  script:
    - git diff --name-only ${CI_COMMIT_BEFORE_SHA} ${CI_COMMIT_SHA} >> ./${CHANGES_INFO}
    - cat ./${CHANGES_INFO}
    #
  artifacts:
    expire_in: 6 hours
    paths:
      - ./cicd-script/build-docker/

# Define the "don't run build jobs when triggering cleaning jobs" as a reusable YAML anchor
#
.do-not-run-build-run-when-cleaning: &do-not-run-build-run-when-cleaning
  - if: $ENABLE_BUILD != 'yes'
    when: never
  - if: $CI_COMMIT_MESSAGE =~ /ci-clean-/
    when: never
  # always run in other cases (if previous job didn't fail)
  - when: on_success

# Uses the python script to fill the missing part of the Jsonnet file
#
fill-jsonnet-from-python:
  stage: process
  rules:
    - *do-not-run-build-run-when-cleaning
  tags:
    - $RUNNER_TAGS
  needs:
    - get-changes-from-git
  #
  image: ${REGISTRY_DOMAIN}${CICD_NAMESPACE}${PYTHON_PROCESS_PATH}:${PYTHON_PROCESS_TAG}
  script:
    - python3 ${PYTHON_SCRIPT}
      --debug-enabled ${CI_DEBUG}
      --generate-jsonnet 
      --generate-jsonnet-destination-file ${JSONNET_SRC} 
      --generate-jsonnet-current-repo ${CI_PROJECT_NAME} 
      --generate-jsonnet-branch-name ${CI_COMMIT_BRANCH}
      --generate-jsonnet-pipeline-folder ${CI_PIPELINE_FOLDER_PATH}
      --changes-info-file ${CHANGES_INFO} 
      --project-id ${CI_PROJECT_ID} 
      --token ${CICD_API_TOKEN} 
      --trigger-project ${CI_PROJECT_TRIGGER_CICD} 
      --trigger-branch ${CI_BRANCH_TRIGGER_CICD}
      --trigger-changes "${CI_CHANGES_TRIGGER_CICD}"
      --trigger-variables "${CI_TRIGGER_VARIABLES_CICD}"
      --pipeline-source ${CI_PIPELINE_SOURCE}
  #
  artifacts:
    expire_in: 6 hours
    paths:
      - ./cicd-script/

# Translates the Jsonnet file into a YAML configuration file
#
convert-jsonnet-to-json:
  stage: convert
  rules:
    - *do-not-run-build-run-when-cleaning
  tags:
    - $RUNNER_TAGS
  needs:
    - fill-jsonnet-from-python
  #
  image: 
    name: ${REGISTRY_DOMAIN}${CICD_NAMESPACE}${JSONNET_FOLDER_PATH}:${JSONNET_FOLDER_TAG}
  #
  script:
    - /entrypoint.sh
  #
  artifacts:
    expire_in: 6 hours
    paths:
      - ./cicd-script/

# Uses the YAML configuration file to create and run jobs
# 
execute-jobs-from-yaml:
  stage: execute
  rules:
    - *do-not-run-build-run-when-cleaning
  needs:
    - convert-jsonnet-to-json
  #
  # Force passing variables into child jobs
  variables:
    # Gitlab variables
    CICD_SOURCE: "${CI_PIPELINE_SOURCE}"
    CICD_COMMIT: "${CI_COMMIT_MESSAGE}"
    TRIGGER_DESCRIPTION: "${TRIGGER_DESCRIPTION}"
    RUNNER_TAGS: "${RUNNER_TAGS}"
    PARENT_PIPELINE_ID: $CI_PIPELINE_ID
  #
  trigger:
    include:
      - artifact: "${CI_PIPELINE_YAML_FOLDER_PATH}/pipelines.yaml"
        job: convert-jsonnet-to-json
    strategy: depend
    forward:
      pipeline_variables: true